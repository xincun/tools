[Total]
cmdtotal=75

[commands]
0=$RESULT
1=$VERSION
2=#INC
3=#LOG
4=ADD
5=AI
6=AN
7=AND
8=ASK
9=ASM
10=AO
11=BC
12=BP
13=BPCND
14=BPL
15=BPLCND
16=BPMC
17=BPHWC
18=BPHWS
19=BPRM
20=BPWM
21=CMP
22=CMT
23=COB
24=COE
25=DBH
26=DBS
27=DEC
28=DM
29=DMA
30=DPE
31=EOB
32=EOE
33=ESTI
34=ESTO
35=EVAL
36=EXEC/ENDE
37=FIND
38=FINDOP
39=GN
40=GPA
41=GO
42=GMI
43=INC
44=JA
45=JAE
46=JB
47=JBE
48=JE
49=JMP
50=JNE
51=LBL
52=LOG
53=MOV
54=MSG
55=MSGYN
56=OR
57=PAUSE
58=REPL
59=RET
60=RTR
61=RTU
62=RUN
63=SHL
64=SHR
65=STI
66=STO
67=SUB
68=TI
69=TICND
70=TO
71=TOCND
72=VAR
73=XOR
74=FILL


[info]
0=保存某些函数的返回值，比如FIND函数，等等。
1=保存OllyScript，的版本信息.\例：\cmp $VERSION, "0.8"  //比较是否大于 0.8版\ja version_above_08
2=将一个脚本文件的内容包含到另外一个脚本文件中\例:\#inc "anotherscript.txt"
3=开始记录运行指令\指令会显示在OllyDbg的log窗口中，每条记录前都会加上“-->”的前缀\例：\#log
4=源操作数与目的操作数相加，并把相加的结果保存到目的操作数中。\例： \add x, 0F\add eax, x\add [401000], 5\add y, " times" // 如果在次之前y="1000" ，则在执行完此指令之后y="1000 times"
5=在OllyDbg中执行“自动步入” [Animate into]操作。\例：\ai
6=从指定处，对代码进行分析。\例：\an eip // 相当于在OllyDbg中按 Ctrl+A键
7=源操作数与目的操作数进行逻辑与操作，并将结果保存到到目的操作数中。\例： \and x, 0F\and eax, x\and [401000], 5
8=显示一个提示输入框，让用户输入，并将结果保存转保留变量$RESULT中（如果用户按了取消键，则$RESULT=0）。\例:\ask "Enter new EIP"\cmp $RESULT, 0\je cancel_pressed\mov eip, $RESULT
9=修改指定地址的指令。\并将修改后的汇编指令长度保存到保留变量$RESULT中\例：\asm eip, "mov eax, ecx" //将当前指令修改为 mov eax,ecx
10=在OllyDbg中执行“自动步过” [Animate over]操作。\例：\ao
11=清除指定地址的断点。\例：\bc 401000\bc x\bc eip
12=在指定地址设断点\例：\bp 401000\bp x\bp eip
13=在指定地址处，设置条件断点。\例：\bpcnd 401000, "ECX==1" //当 代码执行到401000且 ecx等于1 时，程序暂停
14=在指定地址处设置记录断点，将表达式的结果记录到记录窗口中。\例：\bpl 401000, "eax" // 每次执行到401000时，都将eax寄存器的结果记录
15=在指定地址处设置记录断点，如果条件为真时，将表达式的结果记录到记录窗口中。\例：\bplcnd 401000, "eax", "eax > 1" // 如果执行到401000时，满足eax>1，则将eax寄存器的结果记录
16=清除内存断点。\例：\bpmc
17=删除指定地址处的硬件断点。\例：\bphwc 401000 //清除 401000处的断点
18=在指定地址，设置硬件断点。有三种模式： "r" - 读取, "w" - 写入 或者 "x" - 执行.\例：\bphws 401000, "x" //当执行到此地址时发生中断
19=在指定地址处，设置一个内存读取断点。 “大小” 是指内存中的字节大小。\例：\bprm 401000, FF  //一个字节
20=在指定地址处，设置一个内存写入断点。“大小” 是指内存中的字节大小。\例：\bpwm 401000, FF
21=比较 目的操作数与源操作数的大小，和其对应的汇编指令作用相同。\例： \cmp y, x\cmp eip, 401000
22=在指定地址处，加入注释。\例：\cmt eip, "这是入口" //当前地址处 加上 “这是入口”的注释
23=发生中断后，让脚本继续执行（移除EOB指令）\例：\COB
24=发生异常后，让脚本继续执行（移除EOE指令）\例：\COE
25=隐藏调试器\例：\dbh
26=对隐藏的调试器操作进行恢复，不再隐藏。\例：\dbs\
27=对变量进行减一操作\例：\dec v
28=从指定地址处开始，在内存中提取指定大小的数据，并保存到指定的文件中\例：\dm 401000, 1F, "c:\dump.bin"
29=从指定地址处开始，在内存中提取指定大小的数据，并保存到指定的文件中；如果指定文件已存在，则将数据追加到指定文件尾部。\例：\dma 401000, 1F, "c:\dump.bin"
30=提取执行模块到指定文件中。\“入口”用来设定入口地址。\例：\dpe "c:\test.exe", eip //入口为当前地址，保存为C盘下test.exe
31=在下次中断发生时，跳转到指定标签处.\例：\eob SOME_LABEL
32=在下次异常发生时，跳转到指定标签处。\例：\eoe SOME_LABEL
33=相当于在OllyDbg按 SHIFT-F7。\例：\esti
34=相当于在OllyDbg按 SHIFT-F9。\例：\esto
35=对当前调试进程，执行在EXEC和ENDE之间的指令。\有大括号的，会被大括号中的变量的值替代。\例：\// 以下是做移动操作\var x\var y\mov x, "eax"\mov y, "0DEADBEEF"\exec\mov { x }, { y } // mov eax, 0DEADBEEF 将被执行\mov ecx, { x } // mov ecx, eax 将被执行\ende\// 以下是调用调试程序的ExitProcess函数\exec\push 0\call ExitProcess\ende\ret
36=对当前调试进程，执行在EXEC和ENDE之间的指令。\有大括号的，会被大括号中的变量的值替代。\例：\// 以下是做移动操作\var x\var y\mov x, "eax"\mov y, "0DEADBEEF"\exec\mov { x }, { y } // mov eax, 0DEADBEEF 将被执行\mov ecx, { x } // mov ecx, eax 将被执行\ende\// 以下是调用调试程序的ExitProcess函数\exec\push 0\call ExitProcess\ende\ret
37=从指定地址开始在内存中查找指定的内容。\如果查找成功，地址会保存到保留变量$RESULT中，否则$RESULT将等于 0。\查找的串支持通配符“??”(见下面的例子)。\例：\find eip, #6A00E8# // 查找一个Call，其的第一个参数为0 (push 0)\find eip, #6A??E8# // 查找一个带参数的Call
38=从指定地址开始查找指定一个指令，这个指令是以指定内容为开始的。 \如果查找成功，地址会保存到保留变量$RESULT中，否则$RESULT将等于 0。\查找的串支持通配符“??”(见下面的例子)。\例：\findop 401000, #61# // find next POPAD\findop 401000, #6A??# // find next PUSH of something\\译者注：\对比一下FIND 和FINDDOP的区别：\地址          数据                 代码\00401007      B8 3300          MOV     EAX, 33\0040100C      33F6                 XOR     ESI, ESI\find 401007,  #33#    //$RESULT等于401008\finddop 401007, #33#  //$RESULT等于40100C
39=获得指定地址的符号名（比如指向API函数）。\符号名将保存到保留变量$RESULT中。如果符号名是一个API函数，则$RESULT_1保存链接库名（比如 kernal32）而 $RESULT_2保存符号名（比如 ExitProcess）。\例：\gn 401000
40=在指定的动态链接库中，获得指定函数的地址。\如果查找成功，地址会保存到保留变量$RESULT中，否则$RESULT将等于 0。\在设置API函数断点时，这个指令非常有效。\例：\gpa "MessageBoxA", "user32.dll" // 这条指令执行后，$RESULT等于函数MessageBoxA的地址，您可以使用"bp $RESULT"设置断点。
41=执行到指定地址处 (相当于SoftICE中的 G 命令)\例：\go 401005
42=获得指定地址所在模块的相关信息。\“信息”可以是模块基地址[MODULEBASE], 模块大小[MODULESIZE], 代码段基地址[CODEBASE] 或者 代码段大小[CODESIZE] \(如果您想在将来的版本中，获得更多的信息，请联系我)。\信息会保存到保留变量$RESULT中 (如果没有找到信息，则$RESULT等于0).\例：\GMI eip, CODEBASE // 这条指令执行后，$RESULT等于当前所在模块的代码段基地址。
43=对变量进行加一操作\例：\inc v
44=在cmp命令后使用. 和其对应的汇编指令作用相同.\例：\ja SOME_LABEL
45=cmp. 和其对应的汇编指令作用相同.\例：\jae SOME_LABEL
46=在cmp命令后使用.  和其对应的汇编指令作用相同.\例：\jb SOME_LABEL
47=在cmp命令后使用。和其对应的汇编指令作用相同.\例：\jbe SOME_LABEL
48=在cmp命令后使用.  和其对应的汇编指令作用相同.\例：\je SOME_LABEL
49=<JuMP>\跳转到指定标签.\例：\jmp SOME_LABEL
50=在cmp命令后使用.  和其对应的汇编指令作用相同.\例：\jne SOME_LABEL
51=在指定地址处插入一个标签\例：\lbl eip, "NiceJump"
52=将源操作数输出到OllyDbg的记录窗口[log window]中。\如果源操作数 是一个字符串常量，则原样记录。\例：\log "Hello world" // 记录为 "Hello world"\var x\mov x, 10\log x // 记录为 "x = 00000010"\如果源操作数 是一个变量或一个寄存器，则记录名称及其存放的数值
53=将源操作数移动到目的操作数中。\源操作数可以是一个十六进制序列格式#某个十六进制序列#，例如：#1234#。\提醒：十六进制序列的位长只能是偶数，比如2, 4, 6, 8等等.\例： \mov x, 0F\mov y, "Hello world"\mov eax, ecx\mov [ecx], #00DEAD00BEEF00#\mov !CF, 1\mov !DF, !PF\mov [403000], "Hello world"
54=将指定消息，显示到一个对话框中。\例：\MSG "脚本暂停"\
55=将指定消息，显示到一个对话框中，这个对话框有“是”、“否”按钮。\如果点“是”，保留变量 $RESULT 等于1，否则保留变量$RESULT等于0 。\例：\MSGYN "继续？"
56=源操作数和目的操作数做逻辑或操作，并将结果保存到到目的操作数中。\例： \or x, 0F\or eax, x\or [401000], 5
57=暂停脚本运行。可以通过插件菜单恢复脚本运行。
58=在指定地址开始，在指定长度字节内，用“替换字符串”替换“查找字符串”。\允许使用通配符\例：\repl eip, #6a00#, #6b00#, 10\repl eip, #??00#, #??01#, 10\repl 401000, #41#, #90#, 1F
59=退出脚本。\例：\ret
60=相当于在OllyDbg中执行 "Run to return" [Ctrl+F9]操作。\例：\rtr
61=相当于在OllyDbg中执行 "Run to user code"[Alt+F9] 操作。\例：\rtu
62=相当于在OllyDbg中按 F9。\例：\run
63=左移目的操作数，n比特位；并将结果保存到到目的操作数中。\例：\mov x, 00000010\shl x, 8 // x is now 00001000
64=右移目的操作数,n 比特位；并将结果保存到到目的操作数中。\例：\mov x, 00001000\shr x, 8 // x is now 00000010
65=相当于在OllyDbg中按 F7，单步步入。\例：\sti
66=相当于在OllyDbg中按 F8，单步步过。\例：\sto
67=和汇编里的sub一样，两个数相减\Example: \sub x, 0F\sub eax, x\sub [401000], 5
68=相当于在OllyDbg中执行 "Trace into" 操作。\例：\ti
69=执行 "Trace into" 操作，直到条件为真时停止。\例：\ticnd "eip > 40100A" // 当 eip > 40100A 时停止
70=相当于在OllyDbg中执行 "Trace over" 操作。\例：\to
71=执行 "Trace over" 操作，直到条件为真时停止。\例:\tocnd "eip > 40100A" // 当 eip > 40100A 时停止
72=在脚本中，声明一个变量。\必须在变量使用先声明。\例： \var x
73=源操作数与目的操作数进行异或操作，并将结果保存到到目的操作数中。\例： \xor x, 0F\xor eax, x\xor [401000], 5
74=从指定地址处，填充指定长度的值.

[args]
0=<RESULT>
1=$VERSION
2=#INC "文件名"
3=#LOG
4=ADD 目的操作数,源操作数
5=AI
6=AN 地址
7=AND 目的操作数, 源操作数
8=ASK 问题
9=ASM 地址, 指令
10=AO
11=BC 地址
12=BP ADDR
13=BPCND 地址, 条件
14=BPL 地址, 表达式
15=BPLCND 地址, 表达式, 条件
16=BPMC
17=BPHWC 地址
18=BPHWS 地址, 模式
19=BPRM 地址, 大小
20=BPWM 地址, 大小
21=CMP 目的操作数, 源操作数
22=CMT 地址, 字符串
23=COB
24=COE
25=DBH
26=DBS
27=DEC 变量
28=DM 地址, 大小, 文件名
29=DMA 地址, 大小, 文件名
30=DPE 文件名, 入口
31=EOB 标签
32=EOE 标签
33=ESTI
34=ESTO
35=EVAL
36=EXEC/ENDE
37=FIND 地址, 查找内容
38=FINDOP 地址, 查找内容
39=GN 地址
40=GPA 函数名, 动态链接库名
41=GO 地址
42=GMI 地址, 信息
43=INC 变量
44=JA 标签
45=JAE 标签
46=JB 标签
47=JBE 标签
48=JE 标签
49=JMP 标签
50=JNE 标签
51=LBL 地址, 字符串
52=LOG 源操作数
53=MOV 目的操作数, 源操作数
54=MSG 消息
55=MSGYN 消息
56=OR 目的操作数, 源操作数
57=PAUSE
58=REPL 地址, 查找字符串, 替换字符串, 长度
59=RET
60=RTR
61=RTU
62=RUN
63=SHL 目的操作数, N
64=SHR 目的操作数, N
65=STI
66=STO
67=SUB 目标数据,源数据
68=TI
69=TICND 条件
70=TO
71=TOCND 条件
72=VAR 变量名
73=XOR 目的操作数, 源操作数
74=FILL 地址, 长度, 值